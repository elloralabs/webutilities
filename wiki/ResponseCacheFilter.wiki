#summary In memory caching of static resources responses at server side
#sidebar TableOfContents

We can cache the resources at client side using Cache-Control and Expires header using JSCSSMergeServelet. However sometimes if client cache is disabled by user, the resources get read from disk again and then served. Disk operations are costly. In our case when we can chain the performance filters like merging (JSCSSMergeServlet) , minifying (YUIMinFilter) and then compressing (CompressionFilter). New request for the same resources will have to go through each filter though we had already performed those optimization few minutes/seconds ago. In such cases having caching mechanism at server side improves significant performance.

*ResponseCacheFilter* is meant to serve that purpose. It caches the previously merged, minified and gziped response and serves from the cache next time. If any of resource in the request have been modified on the disk since last caching time, it also smartly reloads the cache with fresh contents and returns updated contents. 

== Configuration ==

Declare this Filter in your web.xml ( web descriptor file)

{{{
<filter>
        <filter-name>responseCacheFilter</filter-name>
        <filter-class>com.googlecode.webutilities.filters.ResponseCacheFilter</filter-class>
 </filter>
}}}

Map this filter on your JS and CSS resources.

{{{
<filter-mapping>
   <filter-name>responseCacheFilter</filter-name>
   <url-pattern>*.js</url-pattern>
   <url-pattern>*.json</url-pattern>
   <url-pattern>*.css</url-pattern>
 </filter-mapping>
}}}

== Usage ==

Nothing much. Requested JS and CSS will pass through this Servlet and will get cached until it get modified on the disk. All subsequent responses will be much faster due to caching.

== Customization ==

  * *reloadTime* - interval in seconds after which resource cache will be reloaded
  * *resetTime* - interval in seconds after which whole cache will be cleared 

Besides above parameters, each filter has following common parameters to better customize and configure it.

  * *ignoreURLPattern* - to ignore the URLs matching this regex. e.g. `.*\.(jpg|png|gif)`.
  * *acceptURLPattern* - to process the URLs matching this regex (ignore precedes). e.g. `.*\.(css|js|html)`.
  * *ignoreMIMEPattern* - to ignore if the response mime matches this regex. e.g. `images/.*|video/.*`.
  * *acceptMIMEPattern* - to process if the response mime matches this regex (ignore precedes). e.g. `text/css|text/html`.
  * *ignoreUAPattern* - to ignore if request user agent name matches this regex. e.g. `MSIE|KHTML`.
  * *acceptUAPattern* - to process if request user agent name matches this regex (ignore precedes). e.g. `WebKit|Opera`.

== About these patterns ==

 * If ignore pattern is not specified, it is treated as nothing to ignore.
 * If accept pattern is not specified, it is treated as everything to accept.
 * If resource matches both ignore and accept, ignore will take precedence.
 * If resource matches ignore pattern but not accept pattern, obviously it will not be processed by the filter. 
 * If resource doesn't match ignore pattern but match accept pattern, then it will be processed by the filter.
 * If resource doesn't match ignore as well as accept pattern, it will not be processed.
=== URL parameters ===

Sometimes you may not want to use cache or you may want to evict the cache. Using below mentioned URL parameters you can do that.

*URL Parameters to skip or evict the cache*

  * * `_skipcache_`* - The JS or CSS request URL if contains this parameters the cache will not be used for it.
  * * `_dbg_`*- same as above _skipcache_ parameter.
  * * `_expirecache_`* - The cache for requested resource will be cleared. 
  * * `_resetcache_`* - The whole cache will be reseted and all contents will cleared from cache
 
 Eg.
{{{
 <link rel="StyleSheet" href="/myapp/css/common.css?_dbg_=1"/>
}}}
 or
{{{
 <script language="JavaScript" src="/myapp/js/prototype.js?_expirecache_=1"></script>
}}}