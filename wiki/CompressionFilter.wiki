#summary Handle compressed requests and return compressed response if accepted by the browser.
#sidebar TableOfContents

[http://developer.yahoo.com/performance/rules.html#gzip Enabling Compression] reduces transfer size of the resources.  This can significantly reduce the time to send resources over the network because contents will be transferred in compressed format. There are various compression encodings like {{{gzip, deflate, compress}}} etc. HTTP request initiated by browser contains the information about whether browser is capable to handle the compressed contents. This is specified using `Accept-Encoding` HTTP header and it contains list of compressions supported by browser and also accepted quality factor (q). Server then can send the compressed response and specify compression encoding in `Content-Encoding` header of the response. Some clients may even be able to able to send request data itself in compressed format and in that case request `Content-Encoding` will specify the compression encoding.

*[CompressionFilter]* supports two way compression. It can uncompress the requests if compressed and can also respond with compressed contents to the requests who accept compressed contents (`Accept-Encoding`). Currently it implements three compression encodings - `gzip, compress and deflate`.

== Configuration ==

Declare this Filter in your web.xml ( web descriptor file)
{{{

<filter>
        <filter-name>compressionFilter</filter-name>
        <filter-class>com.googlecode.webutilities.filters.CompressionFilter</filter-class>
        <init-param> 
                <param-name>compressionThreshold</param-name>
                <param-value>1024</param-value> <!-- compress anything above 1kb -->
        </init-param>
        <init-param> 
                <param-name>ignoreURLPattern</param-name>
                <param-value>.*\.(flv|mp3|mpg)</param-value> <!-- regex -->
        </init-param>
        <init-param> 
                <param-name>ignoreMimes</param-name>
                <param-value>images/*,video/*, multipart/x-gzip</param-value> <!-- ignore -->
        </init-param>
        <init-param> 
                <param-name>ignoreUserAgentsPattern</param-name>
                <param-value>.*MSIE.*</param-value> <!-- regex -->
        </init-param>
 </filter>

}}}
Map this filter on your web requests
{{{
 <filter-mapping>
   <filter-name>compressionFilter</filter-name>
   <url-pattern>*</url-pattern>
 </filter-mapping>
}}}
== Usage ==

Nothing needed. As configured above, resources meeting the compression criteria will be compressed with appropriate compression encoding.  

== Customization ==

It can be customized using the init parameters.

  * *compressionThreshold* - Resource of size larger than this bytes will be compressed.

Besides above parameter, each filter has following common parameters to better customize and configure it.

  * *ignoreURLPattern* - to ignore the URLs matching this regex. e.g. `.*\.(jpg|png|gif)`.
  * *acceptURLPattern* - to process the URLs matching this regex (ignore precedes). e.g. `.*\.(css|js|html)`.
  * *ignoreMIMEPattern* - to ignore if the response mime matches this regex. e.g. `images/.*|video/.*`.
  * *acceptMIMEPattern* - to process if the response mime matches this regex (ignore precedes). e.g. `text/css|text/html`.
  * *ignoreUAPattern* - to ignore if request user agent name matches this regex. e.g. `MSIE|KHTML`.
  * *acceptUAPattern* - to process if request user agent name matches this regex (ignore precedes). e.g. `WebKit|Opera`.

== About these patterns ==

 * If ignore pattern is not specified, it is treated as nothing to ignore.
 * If accept pattern is not specified, it is treated as everything to accept.
 * If resource matches both ignore and accept, ignore will take precedence.
 * If resource matches ignore pattern but not accept pattern, obviously it will not be processed by the filter. 
 * If resource doesn't match ignore pattern but match accept pattern, then it will be processed by the filter.
 * If resource doesn't match ignore as well as accept pattern, it will not be processed.